// Vyper grammar for Lark

// A module is a sequence of definitions and methods (and comments).
// NOTE: Start symbol for the grammar
// NOTE: Module can start with docstring
module: ( DOCSTRING
        | COMMENT
        | import
        | struct_def
        | interface_def
        | constant_def
        | variable_def
        | event_def
        | method_def
        | _NEWLINE )*


// Import statements (Supports all styles of Python imports)
!dots: "."+
import_name: NAME ("." NAME)*
import_rename: NAME ("." NAME)* "as" NAME
import_list: (import_name | import_rename) ("," (import_name | import_rename) )* [","]
import_from: "from" (dots? import_name | dots)
import: ( "import" (import_name | import_rename)
        | import_from "import" ( "*" | import_name | import_rename )
        | import_from "import" "(" import_list ")" )


// Constant definitions
// NOTE: Temporary until decorators used
constant_def: NAME ":" "constant" "(" type ")" "=" _expr

variable: NAME ":" type
// NOTE: Temporary until decorators used
variable_with_getter: NAME ":" "public" "(" type ")"
variable_def: variable | variable_with_getter

// A decorator "wraps" a method, modifying it's context.
// NOTE: One or more can be applied (some combos might conflict)
decorator: "@" NAME [ "(" [arguments] ")" ] _NEWLINE
decorators: decorator+

// Methods take a list of zero or more typed parameters,
// and can return up to one parameter.
// NOTE: Parameters can have a default value,
//       which must be a constant or environment variable.
parameter: NAME ":" type ["=" _expr]
parameters: parameter ("," parameter?)*

method_type: "def" NAME "(" [parameters] ")" ["->" type]
method_def: [decorators] method_type ":" [DOCSTRING] body

indexed_event_arg: NAME ":" "indexed" "(" type ")"
// Events can have zero args
event_def: NAME ":" "event" "(" "{" (variable | indexed_event_arg)? ("," (variable | indexed_event_arg))* "}" ")"


// Types
array_def: (NAME | array_def) "[" (DEC_NUMBER | NAME) "]"
tuple_def: "(" ( NAME | array_def | tuple_def ) ( "," ( NAME | array_def | tuple_def ) )* [","] ")"
// NOTE: Map takes a basic type and maps to another type (can be non-basic, including maps)
map_def: "map" "(" ( NAME | array_def ) "," type ")"
type: ( NAME | array_def | tuple_def | map_def )

// Structs can be composed of 1+ basic types or other custom_types
struct_member: NAME ":" type
struct_def: "struct" NAME ":" _NEWLINE _INDENT (struct_member _NEWLINE)+ _DEDENT

// Interfaces are composed of a series of method definitions, plus their mutability
MUTABILITY: ( "modifying" | "constant" )
interface_def: "contract" NAME ":" _NEWLINE _INDENT (method_type ":" MUTABILITY _NEWLINE)+ _DEDENT


// Statements
_stmt: ( declaration
       | assign
       | aug_assign
       | if_stmt
       | for_stmt
       | return_stmt
       | pass_stmt
       | break_stmt
       | continue_stmt
       | log_stmt
       | raise_stmt
       | assert_stmt
       | _expr ) [COMMENT]

declaration: variable "=" _expr
multiple_assign: (variable_access | "_") ("," (variable_access | "_"))+
assign: (variable_access | multiple_assign | "(" multiple_assign ")" ) "=" _expr
// NOTE: Keep these in sync with bin_op below
?aug_operator: "+"   -> add
             | "-"   -> sub
             | "*"   -> mul
             | "/"   -> div
             | "%"   -> mod
             | "**"  -> pow
             | "<<"  -> shl
             | ">>"  -> shr
             | "and" -> and
             | "or"  -> or
             | "xor" -> xor
aug_assign: variable_access aug_operator "=" _expr

?pass_stmt: "pass"
?break_stmt: "break"
?continue_stmt: "continue"

// TODO: Remove "." as unnecessary
log_stmt: "log" "." NAME "(" [arguments] ")"
return_stmt: "return" _expr ("," _expr)*
raise_stmt: "raise" [STRING]
assert_stmt: "assert" _expr ["," STRING]

body: _NEWLINE _INDENT (COMMENT | _NEWLINE | _stmt)+ _DEDENT
if_stmt: "if" _expr ":" body ("elif" _expr ":" body)* ["else" ":" body]
// TODO: make this into a variable definition e.g. `for i: uint256 in range(0, 5): ...`
for_stmt: "for" NAME "in" _expr ":" body


// Expressions
_expr: operation
     | dict

get_item: variable_access "[" _expr "]"
get_attr: variable_access "." NAME
call: variable_access "(" [arguments] ")"
?variable_access: NAME -> get_var
                | get_item
                | get_attr
                | call
                | "(" variable_access ")"

?argument: _expr ["=" _expr]
arguments: argument ("," argument)* [","]

tuple: "(" _expr ( ("," _expr)+ | "," ) ")"
list: "[" _expr ("," _expr)* [","] "]"
dict: "{" (NAME ":" _expr) ("," (NAME ":" _expr))* [","] "}"

literal: ( number | STRING | BOOL )


// Operators
// NOTE: The recursive cycle here helps enforce operator precedence
//       Precedence goes up the lower down you go
?operation: bin_op

// Binary Operations
// NOTE: Keep these in sync with aug_assign above
?bin_op: product
      | bin_op "+"   product -> add
      | bin_op "-"   product -> sub
      | bin_op "<<"  product -> shl
      | bin_op ">>"  product -> shr
?product: power
      | product "*"   power -> mul
      | product "/"   power -> div
?power: bool_op
      | power "**"  bool_op -> pow
      | power "%"   bool_op -> mod

// Boolean Operations
?bool_op: unary_op
       | bool_op "and" unary_op -> and
       | bool_op "or"  unary_op -> or
       | bool_op "xor" unary_op -> xor

// Unary Operations
?unary_op: comparator
        | "+"   unary_op -> uadd
        | "-"   unary_op -> usub
        | "not" unary_op -> not

// Comparisions
?comparator: atom
          | comparator "<"  atom ->  lt
          | comparator ">"  atom ->  gt
          | comparator "==" atom ->  eq
          | comparator "!=" atom ->  ne
          | comparator "<=" atom ->  le
          | comparator ">=" atom ->  ge
          | comparator "in" atom ->  in

// NOTE: Must end recursive cycle like this (with `atom` calling `operation`)
?atom: variable_access
     | literal
     | tuple
     | list
     | "(" operation ")"


// Tokens
// Adapted from Lark repo. https://github.com/lark-parser/lark/blob/master/examples/python3.lark
// Adapted from: https://docs.python.org/3/reference/grammar.html
// Adapted by: Erez Shinan
NAME: /[a-zA-Z_]\w*/
COMMENT: /#[^\n]*/
_NEWLINE: ( /\r?\n[\t ]*/ | COMMENT )+


STRING: /[ubf]?r?("(?!"").*?(?<!\\)(\\\\)*?"|'(?!'').*?(?<!\\)(\\\\)*?')/i
DOCSTRING: /[ubf]?r?(""".*?(?<!\\)(\\\\)*?"""|'''.*?(?<!\\)(\\\\)*?''')/is

DEC_NUMBER: /0|[1-9]\d*/i
HEX_NUMBER.2: /0x[\da-f]*/i
OCT_NUMBER.2: /0o[0-7]*/i
BIN_NUMBER.2 : /0b[0-1]*/i
FLOAT_NUMBER.2: /((\d+\.\d*|\.\d+)(e[-+]?\d+)?|\d+(e[-+]?\d+))/i
?number: DEC_NUMBER | HEX_NUMBER | BIN_NUMBER | OCT_NUMBER | FLOAT_NUMBER

BOOL: "True" | "False"

%ignore /[\t \f]+/  // WS
%ignore /\\[\t \f]*\r?\n/   // LINE_CONT
%ignore COMMENT
%declare _INDENT _DEDENT
